<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html>
  <head>
    <title>ocamljs 0.1 - compile</title>
  </head>
  <body>

<h3>How ocamljs compiles OCaml</h3>

<p>Ocamljs uses the ocamlc front-end up to the point where it
generates 'lambda' code--an untyped representation that looks a lot
like Lisp. (You can see the lambda representation of OCaml code with
the -dlambda option to ocamlc or ocamljs.)</p>

<p>The translation is very direct: OCaml functions turn into
Javascript functions, OCaml exception handling to Javascript exception
handling, etc. Javascript distinguishes between expressions and
statements, while OCaml has only expressions, so there are two
compilations for most OCaml constructs, depending on which context the
construct appears in.</p>

<p>One difference between OCaml and Javascript is that functions in
OCaml may be applied to a different number of arguments than they are
defined to take. So OCaml function application is not compiled to
Javascript function application, but rather to a call to an apply
method which checks the number of arguments and either returns a
closure (for under-application) or tail calls the result of the
application with the extra arguments (for over-application). See
Xavier Leroy's
talk <a href="http://pauillac.inria.fr/~xleroy/talks/zam-kazam05.pdf">From
Krivine's machine to the Caml implementations</a>.</p>

<p>This apply method is also where tail-recursion is implemented,
using trampolines. See lib/support.js for details.</o>

<p>Much of standard OCaml is implemented by a library of C primitives;
Javascript implementations of these (insofar as they have been
implemented) are in lib/primitives.js. Some OCaml primitives are
implemented directly by the code generator; see comp_ccall in
src/jsgen.ml.</p>

<h3>How ocamljs represents OCaml values in Javascript</h3>

<p>OCaml ints, nativeints, int32s, floats, and characters are
represented by Javascript numbers. There is no support for int64s.</p>

<p>OCaml booleans are represented by either Javascript numbers or
booleans. OCaml lambda expressions don't distinguish between ints and
bools (it would be nice if they kept types around), but the Javascript
boolean operations return booleans. It would be inconvenient to
convert back and forth and/or reconstruct the types in order to
eliminate the conversions. 0 and 1 are acceptable in place of false
and true as operands to Javascript operators, but be careful of this
when interfacing to other code, which may distinguish between
them.</p>

<p>OCaml heap blocks (used in OCaml to represent records, variants,
polymorphic variants, exceptions, and arrays) are represented by
Javascript arrays. Blocks may have a tag (used to distinguish branches
of variants), which is represented as an extra slot on the array
object. See lib/support.js for functions on blocks.</p>

<p>OCaml strings are mutable, but Javascript strings are immutable, so
a direct representation is not possible. Ocamljs represents mutable
strings as arrays of numbers (since it represents characters as
numbers). However, this representation seems expensive, and most of
the time you don't want to mutate your strings anyway, so OCaml
strings may also be represented by immutable Javascript strings. If
you write a literal string in OCaml, you get a literal string in
Javascript, but if you create a string with String.create (that is,
with the caml_create_string primitive) you get an array representing a
mutable string. You can read the elements of either string as usual,
but writing to an immutable string fails (at present with an
inscrutable error). Note that Pervasives.(^) calls
caml_create_string. At some point we should do something better
here.</p>

</body>
</html>
